/**
 * Generated by JitBlox - rapid interactive prototyping of modern web apps from your browser.
 * Upgrade to a Pro plan to remove this header, see https://www.jitblox.com/plans for more.
 *
 * Check out this JitBlox project, Soluce, at https://www.jitblox.com/project/5JHnGKTPaU/soluce
 */

import { inject, Injectable, signal } from '@angular/core';
import { Problem } from '../model';
import { problem_list_mock } from './problem.service.mock-data';
import { catchError, map, Observable, of, tap, throwError } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { UpdateProblemDto } from '@shared/dto';

@Injectable({ providedIn: 'root' })
export class ProblemService {
  /**
   * fetch problems which groups of user has authorization to work on
   */
  public fetchProblemsOfUserGroups(): Observable<Problem[]> {
    return of(
      problem_list_mock.sort((a, b) => {
        return a.id! - b.id!;
      })
    );
  }

  /**
   * Create a new problem entry.
   *
   * Base mock implementation used in development without a backend. It simulates
   * a server-created entity and maps the boolean visibility flag to the app's
   * string-based `open` field ('Public' | 'Private').
   *
   * @param body The payload expected by the backend service containing the
   * name, an optional description, and a boolean flag for visibility.
   * - When `open` is `true`, visibility is interpreted as 'Public'.
   * - When `open` is `false`, visibility is interpreted as 'Private'.
   * @returns An observable emitting the created {@link Problem}.
   */
  public createProblem(body: { name: string; description?: string; open: boolean }): Observable<Problem> {
    const mockCreated: Problem = {
      id: Math.floor(Math.random() * 100000),
      name: body.name,
      description: body.description,
      open: body.open === true ? 'Public' : 'Private',
    };
    return of(mockCreated);
  }

  /**
   * Update an existing problem entry.
   *
   * Base mock implementation used in development without a backend. It simulates
   * updating a problem by returning the updated problem data with partial updates.
   *
   * @param id The ID of the problem to update
   * @param body The {@link UpdateProblemDto} payload with optional fields for partial updates.
   * - When `open` is `true`, visibility is interpreted as 'Public'.
   * - When `open` is `false`, visibility is interpreted as 'Private'.
   * - All fields are optional, allowing partial updates.
   * @returns An observable emitting the updated {@link Problem}.
   */
  public updateProblem(id: number, body: UpdateProblemDto): Observable<Problem> {
    const mockUpdated: Problem = {
      id: id,
      name: body.name,
      description: body.description,
      open: body.open !== undefined ? (body.open === true ? 'Public' : 'Private') : undefined,
      status: body.status,
    };
    return of(mockUpdated);
  }

  /**
   * Returns the localized status text based on the current locale.
   * This method can be reused across different components that display problem statuses.
   *
   * @param status The status value from the backend
   * @returns The localized status text
   */
  public getLocalizedStatus(status: string | undefined): string {
    if (!status) {
      return '-';
    }

    switch (status.toLowerCase()) {
      case 'new':
        return $localize`New`;
      case 'in progress':
        return $localize`In Progress`;
      case 'blocked':
        return $localize`Blocked`;
      case 'resolved':
        return $localize`Resolved`;
      case 'closed':
        return $localize`Closed`;
      default:
        return status;
    }
  }
}
